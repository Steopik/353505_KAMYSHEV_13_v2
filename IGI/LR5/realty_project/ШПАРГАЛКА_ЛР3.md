# ШПАРГАЛКА ЛР3 - JavaScript задания (Вариант 13)

**Автор**: Камышев
**Группа**: 353505
**Лабораторная работа**: №3 (ЛР3) - JavaScript
**Вариант**: 13

---

## Содержание
1. [Задание 1: Слайдер изображений](#задание-1-слайдер-изображений)
2. [Задание 2: Переключатель темы](#задание-2-переключатель-темы)
3. [Задание 3: Таблица сотрудников](#задание-3-таблица-сотрудников)
4. [Задание 4: Генератор форм (input type="url")](#задание-4-генератор-форм)
5. [Задание 5: Пагинация каталога](#задание-5-пагинация-каталога)
6. [Задание 6: 3D эффект для карточек](#задание-6-3d-эффект-для-карточек)
7. [Задание 7: Проверка возраста](#задание-7-проверка-возраста)
8. [Задание 8: Классы с наследованием (весенние даты)](#задание-8-классы-с-наследованием)
9. [Задание 9: Browser API](#задание-9-browser-api)
10. [Задание 10: График функции (Chart.js)](#задание-10-график-функции)
11. [Задание 11: Анимация при скроллинге](#задание-11-анимация-при-скроллинге)

---

## Задание 1: Слайдер изображений

**Файл**: `static/js/slider.js`
**Страница**: `/js-tasks/`

### Описание
Реализация слайдера изображений с использованием ES6 классов. Слайдер поддерживает автопрокрутку, навигацию стрелками, пагинацию точками, зацикливание и управление с клавиатуры.

### Структура класса

```javascript
class Slider {
    constructor(options) { }  // Конструктор - принимает настройки
    init() { }                // Инициализация слайдера
    next() { }                // Следующий слайд
    prev() { }                // Предыдущий слайд
    goToSlide(index) { }      // Переход к конкретному слайду
    startAutoplay() { }       // Запуск автопрокрутки
    stopAutoplay() { }        // Остановка автопрокрутки
}
```

### Ключевые концепции

#### 1. Конструктор и параметры по умолчанию

```javascript
constructor(options) {
    // Spread оператор (...) объединяет options с настройками по умолчанию
    this.options = {
        container: '#slider',
        loop: true,
        navs: true,
        pags: true,
        auto: false,
        delay: 5,
        stopMouseHover: true,
        ...options  // Переданные параметры перезаписывают значения по умолчанию
    };
}
```

**Объяснение**:
- `...options` - spread оператор "расплющивает" объект options
- Значения из `options` перезаписывают дефолтные значения
- Если какой-то параметр не передан, используется значение по умолчанию

#### 2. Получение DOM элементов

```javascript
this.container = document.querySelector(this.options.container);
this.slides = this.container.querySelectorAll('.slide');
this.prevBtn = this.container.querySelector('.slider-prev');
this.nextBtn = this.container.querySelector('.slider-next');
```

**Объяснение**:
- `querySelector()` - находит ПЕРВЫЙ элемент по CSS-селектору
- `querySelectorAll()` - находит ВСЕ элементы (возвращает NodeList)
- Сохраняем ссылки на элементы в `this`, чтобы использовать во всех методах

#### 3. Переключение слайдов

```javascript
goToSlide(index) {
    // 1. Убираем active у текущего слайда
    this.slides[this.currentIndex].classList.remove('active');

    // 2. Обновляем индекс
    this.currentIndex = index;

    // 3. Добавляем active новому слайду
    this.slides[this.currentIndex].classList.add('active');
}
```

**Объяснение**:
- `classList.remove()` - убирает CSS класс
- `classList.add()` - добавляет CSS класс
- CSS класс `.active` меняет `opacity: 1` и делает слайд видимым

#### 4. Автопрокрутка с setInterval

```javascript
startAutoplay() {
    const delayMs = this.options.delay * 1000;  // Секунды → миллисекунды

    this.autoplayInterval = setInterval(() => {
        if (!this.isHovered) {  // Не крутим, если мышь над слайдером
            this.next();
        }
    }, delayMs);
}

stopAutoplay() {
    if (this.autoplayInterval) {
        clearInterval(this.autoplayInterval);  // Останавливаем интервал
        this.autoplayInterval = null;
    }
}
```

**Объяснение**:
- `setInterval(fn, time)` - вызывает функцию каждые `time` миллисекунд
- `clearInterval(id)` - останавливает интервал
- Стрелочная функция `() => {}` сохраняет контекст `this`

#### 5. Остановка при наведении мыши

```javascript
setupMouseHoverStop() {
    this.container.addEventListener('mouseenter', () => {
        this.isHovered = true;  // Мышь вошла в область слайдера
    });

    this.container.addEventListener('mouseleave', () => {
        this.isHovered = false;  // Мышь вышла из области
    });
}
```

**Объяснение**:
- `mouseenter` - событие входа мыши в элемент
- `mouseleave` - событие выхода мыши из элемента
- Флаг `isHovered` проверяется в `startAutoplay()`

#### 6. Навигация с клавиатуры

```javascript
setupKeyboardNavigation() {
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
            this.prev();
        } else if (e.key === 'ArrowRight') {
            this.next();
        }
    });
}
```

**Объяснение**:
- `keydown` - событие нажатия клавиши
- `e.key` - название нажатой клавиши
- Работает на всей странице (слушатель на `document`)

### Использование

```javascript
const slider = new Slider({
    container: '#propertySlider',
    loop: true,
    auto: true,
    delay: 5
});

// Изменение задержки
slider.updateDelay(3);

// Включение/выключение автопрокрутки
slider.enableAutoplay();
slider.disableAutoplay();
```

---

## Задание 2: Переключатель темы

**Файл**: `static/js/theme-switcher.js`
**Страница**: Все страницы (в шапке сайта)

### Описание
Переключение между светлой и темной темой с сохранением выбора в `localStorage`. Тема применяется сразу при загрузке страницы.

### Структура класса

```javascript
class ThemeSwitcher {
    constructor() { }         // Инициализация констант
    init() { }                // Применение сохраненной темы
    toggleTheme() { }         // Переключение темы
    applyTheme(theme) { }     // Применение темы к HTML
    saveTheme(theme) { }      // Сохранение в localStorage
}
```

### Ключевые концепции

#### 1. Константы для тем

```javascript
constructor() {
    this.STORAGE_KEY = 'preferred-theme';  // Ключ для localStorage
    this.themes = {
        LIGHT: 'light',
        DARK: 'dark'
    };
}
```

**Объяснение**:
- Константы в UPPERCASE - стандартная практика
- Объект `themes` предотвращает опечатки в названиях тем
- `STORAGE_KEY` - единое место для ключа, легко изменить

#### 2. Работа с localStorage

```javascript
// Сохранение
saveTheme(theme) {
    localStorage.setItem(this.STORAGE_KEY, theme);
}

// Получение
getSavedTheme() {
    const saved = localStorage.getItem(this.STORAGE_KEY);
    return saved || this.themes.LIGHT;  // Если нет - вернуть light
}
```

**Объяснение**:
- `localStorage.setItem(key, value)` - сохраняет строку
- `localStorage.getItem(key)` - читает строку (или `null` если нет)
- `||` оператор - если `saved` пустой/null, вернет `this.themes.LIGHT`

#### 3. Применение темы через CSS классы

```javascript
applyTheme(theme) {
    const html = document.documentElement;  // Элемент <html>

    if (theme === this.themes.DARK) {
        html.classList.add('dark-theme');
        html.classList.remove('light-theme');
    } else {
        html.classList.add('light-theme');
        html.classList.remove('dark-theme');
    }

    html.setAttribute('data-theme', theme);  // data-атрибут для CSS
}
```

**Объяснение**:
- `document.documentElement` - это элемент `<html>`
- Добавляем класс `.dark-theme` или `.light-theme`
- CSS селекторы типа `html.dark-theme body { background: #222; }`
- `data-theme` атрибут для CSS селекторов `[data-theme="dark"]`

#### 4. Переключение темы

```javascript
toggleTheme() {
    const currentTheme = this.getSavedTheme();

    // Тернарный оператор: если light → dark, иначе → light
    const newTheme = (currentTheme === this.themes.LIGHT)
        ? this.themes.DARK
        : this.themes.LIGHT;

    this.applyTheme(newTheme);
    this.saveTheme(newTheme);
    this.updateToggleState(newTheme);
    this.showNotification(newTheme);
}
```

**Объяснение**:
- Тернарный оператор: `условие ? значение_если_true : значение_если_false`
- Последовательность: применяем → сохраняем → обновляем UI → показываем уведомление

#### 5. Уведомление о смене темы

```javascript
showNotification(theme) {
    const themeName = (theme === this.themes.DARK) ? 'Темная' : 'Светлая';

    // Создаем элемент уведомления
    const notification = document.createElement('div');
    notification.className = 'theme-notification';
    notification.textContent = `${themeName} тема активирована`;
    document.body.appendChild(notification);

    // Удаляем через 2 секунды
    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
    }, 2000);
}
```

**Объяснение**:
- `document.createElement('div')` - создает новый HTML элемент
- `appendChild()` - добавляет элемент в DOM
- `setTimeout(() => {}, 2000)` - выполнит функцию через 2000 мс (2 сек)
- Вложенный `setTimeout` - сначала добавляем класс fade-out (300ms анимация), потом удаляем

#### 6. Инициализация при загрузке страницы

```javascript
document.addEventListener('DOMContentLoaded', () => {
    window.themeSwitcher = new ThemeSwitcher();
});
```

**Объяснение**:
- `DOMContentLoaded` - событие когда HTML полностью загружен
- `window.themeSwitcher` - делаем объект глобально доступным
- Тема применяется ДО отрисовки страницы (нет "мерцания")

---

## Задание 8: Классы с наследованием (весенние даты)

**Файл**: `static/js/spring-dates.js`
**Страница**: `/js-tasks/`
**Вариант 13**: Работа с датами - фильтрация весенних дат (март, апрель, май)

### Описание
Реализация TWO вариантов наследования:
1. **ES6 классы** - class/extends
2. **Prototypal inheritance** - прототипное наследование

### ВАРИАНТ 1: CLASS / EXTENDS

```javascript
// Базовый класс
class DateManager {
    constructor() {
        this.dates = [];  // Массив объектов дат
    }

    getDates() { return this.dates; }
    setDates(dates) { this.dates = dates; }

    // Добавление даты из формы
    addDateFromForm(day, month, year) {
        const date = {
            day: parseInt(day),
            month: parseInt(month),
            year: parseInt(year)
        };
        this.dates.push(date);
        return date;
    }

    // Вывод всех дат в таблицу
    displayAllDates(containerId) { /*...*/ }
}

// Производный класс
class SpringDateManager extends DateManager {
    constructor() {
        super();  // Вызов конструктора родителя
        this.springMonths = [3, 4, 5];  // Март, апрель, май
    }

    getSpringMonths() { return this.springMonths; }
    setSpringMonths(months) { this.springMonths = months; }

    // Проверка является ли дата весенней
    isSpringDate(date) {
        return this.springMonths.includes(date.month);
    }

    // Фильтрация и вывод весенних дат
    displaySpringDates(containerId) {
        const springDates = this.dates.filter(date => this.isSpringDate(date));
        // ... отображение в таблице
    }

    // Сохранение весенних дат в файл
    saveSpringDatesToFile(filename = 'g.txt') {
        const springDates = this.dates.filter(date => this.isSpringDate(date));

        // Формируем текст
        let content = '===== ВЕСЕННИЕ ДАТЫ =====\n\n';
        springDates.forEach((date, index) => {
            content += `${index + 1}. ${this.formatDate(date)}\n`;
        });

        // Создаем Blob и скачиваем
        const blob = new Blob([content], {type: 'text/plain; charset=utf-8'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
    }
}
```

### ВАРИАНТ 2: PROTOTYPAL INHERITANCE

```javascript
// Базовый "класс" через функцию-конструктор
function DateManagerProto() {
    this.dates = [];
}

// Методы в прототипе
DateManagerProto.prototype.getDates = function() {
    return this.dates;
};

DateManagerProto.prototype.addDateFromForm = function(day, month, year) {
    const date = {
        day: parseInt(day),
        month: parseInt(month),
        year: parseInt(year)
    };
    this.dates.push(date);
    return date;
};

// Производный "класс"
function SpringDateManagerProto() {
    DateManagerProto.call(this);  // Вызов родительского конструктора
    this.springMonths = [3, 4, 5];
}

// Настройка цепочки прототипов
SpringDateManagerProto.prototype = Object.create(DateManagerProto.prototype);
SpringDateManagerProto.prototype.constructor = SpringDateManagerProto;

// Добавляем методы
SpringDateManagerProto.prototype.isSpringDate = function(date) {
    return this.springMonths.includes(date.month);
};

SpringDateManagerProto.prototype.displaySpringDates = function(containerId) {
    const springDates = this.dates.filter(date => this.isSpringDate(date));
    // ... код отображения
};
```

### Ключевые концепции

#### 1. Extends и Super

```javascript
class SpringDateManager extends DateManager {
    constructor() {
        super();  // ОБЯЗАТЕЛЬНО вызвать конструктор родителя
        this.springMonths = [3, 4, 5];
    }
}
```

**Объяснение**:
- `extends` - устанавливает наследование
- `super()` - вызывает конструктор родительского класса
- Без `super()` будет ошибка!

#### 2. Object.create() для прототипов

```javascript
SpringDateManagerProto.prototype = Object.create(DateManagerProto.prototype);
SpringDateManagerProto.prototype.constructor = SpringDateManagerProto;
```

**Объяснение**:
- `Object.create(proto)` - создает новый объект с прототипом `proto`
- Устанавливаем цепочку: `SpringDateManagerProto → DateManagerProto → Object`
- Восстанавливаем `constructor`, иначе он будет указывать на `DateManagerProto`

#### 3. Array.filter() для фильтрации

```javascript
const springDates = this.dates.filter(date => this.isSpringDate(date));
```

**Объяснение**:
- `filter()` создает НОВЫЙ массив с элементами, прошедшими проверку
- Принимает функцию-предикат (возвращает true/false)
- Исходный массив `this.dates` НЕ изменяется

#### 4. Blob API для скачивания файлов

```javascript
const blob = new Blob([content], {type: 'text/plain; charset=utf-8'});
const link = document.createElement('a');
link.href = URL.createObjectURL(blob);
link.download = 'g.txt';
link.click();
```

**Объяснение**:
- `Blob` - объект для хранения бинарных данных
- `URL.createObjectURL()` - создает временную ссылку на Blob
- Создаем невидимую ссылку `<a>` и кликаем программно
- Браузер скачивает файл

### Использование

```javascript
// Вариант 1: ES6 классы
const manager1 = new SpringDateManager();
manager1.addDateFromForm(15, 4, 2024);  // 15 апреля 2024
manager1.addDateFromForm(20, 7, 2024);  // 20 июля 2024
manager1.displaySpringDates('spring-dates-container');
manager1.saveSpringDatesToFile('g.txt');

// Вариант 2: Прототипы
const manager2 = new SpringDateManagerProto();
manager2.addDateFromForm(10, 3, 2024);
manager2.displaySpringDates('spring-dates-proto-container');
```

---

## Задание 10: График функции ln(1+x) - Ряд Тейлора

**Файл**: `static/js/charts-demo.js`
**Страница**: `/js-tasks/`
**Вариант 13**: ln(1 + x) = Σ(n=1 to ∞) (-1)^(n-1) · (x^n / n)

### Описание
Построение графика функции ln(1+x) через разложение в ряд Тейлора и сравнение с Math.log(). Использует библиотеку Chart.js.

### Формула

```
ln(1 + x) = x - x²/2 + x³/3 - x⁴/4 + ...
          = Σ(n=1 to ∞) (-1)^(n-1) · (x^n / n)

Условие сходимости: |x| < 1
```

### Ключевой код

#### 1. Вычисление суммы ряда Тейлора

```javascript
calculateSeriesLn(x, n) {
    if (Math.abs(x) >= 1) return null;  // Проверка сходимости

    let sum = 0;
    for (let i = 1; i <= n; i++) {
        // (-1)^(i-1) · (x^i / i)
        sum += Math.pow(-1, i - 1) * Math.pow(x, i) / i;
    }
    return sum;
}
```

**Объяснение**:
- `Math.abs(x) >= 1` - ряд расходится при |x| ≥ 1
- `Math.pow(-1, i - 1)` - чередование знака (+, -, +, ...)
- `Math.pow(x, i)` - возведение в степень x^i
- Суммируем первые n членов ряда

#### 2. Встроенная функция для сравнения

```javascript
calculateMathLn(x) {
    return Math.log(1 + x);  // Точное значение
}
```

#### 3. Создание графика с Chart.js

```javascript
createFunctionChart() {
    const xValues = [];
    const seriesValues = [];
    const mathValues = [];
    const step = 0.05;
    const n = 50;  // Количество членов ряда

    // Генерируем точки от -0.9 до 0.9
    for (let x = -0.9; x <= 0.9; x += step) {
        xValues.push(x.toFixed(2));
        seriesValues.push(this.calculateSeriesLn(x, n));
        mathValues.push(this.calculateMathLn(x));
    }

    // Создаем график
    const ctx = document.getElementById('functionChart').getContext('2d');
    this.charts.functionChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: xValues,
            datasets: [
                {
                    label: 'F(x) - Разложение в ряд Тейлора',
                    data: seriesValues,
                    borderColor: 'rgb(255, 99, 132)',
                    borderWidth: 2,
                    pointRadius: 0  // Без точек
                },
                {
                    label: 'Math.log(1+x) - Встроенная функция',
                    data: mathValues,
                    borderColor: 'rgb(54, 162, 235)',
                    borderDash: [5, 5],  // Пунктир
                    pointRadius: 0
                }
            ]
        },
        options: {
            animation: {
                duration: 2000,  // 2 секунды
                easing: 'easeInOutQuart'
            },
            responsive: true,
            maintainAspectRatio: false
        }
    });
}
```

**Объяснение**:
- `x.toFixed(2)` - округление до 2 знаков после запятой
- `borderDash: [5, 5]` - пунктирная линия (5px линия, 5px пропуск)
- `pointRadius: 0` - не рисовать точки на линии
- `easing: 'easeInOutQuart'` - тип анимации

#### 4. Таблица значений и погрешность

```javascript
generateTable() {
    const xTestValues = [-0.8, -0.5, -0.2, 0, 0.2, 0.5, 0.8];
    const tbody = document.getElementById('values-table-body');
    tbody.innerHTML = '';

    xTestValues.forEach(x => {
        const n = 50;
        const seriesValue = this.calculateSeriesLn(x, n);
        const mathValue = this.calculateMathLn(x);
        const epsilon = Math.abs(mathValue - seriesValue);  // Погрешность

        const row = `
            <tr>
                <td>${x}</td>
                <td>${n}</td>
                <td>${seriesValue.toFixed(6)}</td>
                <td>${mathValue.toFixed(6)}</td>
                <td style="color: ${epsilon < 0.0001 ? '#27ae60' : '#e67e22'}">
                    ${epsilon.toFixed(8)}
                </td>
            </tr>
        `;
        tbody.innerHTML += row;
    });
}
```

**Объяснение**:
- `Math.abs(a - b)` - абсолютная погрешность
- `toFixed(6)` - 6 знаков после запятой
- Цвет зависит от погрешности: зеленый если < 0.0001, оранжевый иначе

#### 5. Перезапуск анимации

```javascript
restartAnimation() {
    if (this.charts.functionChart) {
        this.charts.functionChart.destroy();  // Удаляем старый график

        setTimeout(() => {
            this.createFunctionChart();  // Создаем заново
        }, 100);
    }
}
```

#### 6. Сохранение графика в файл

```javascript
saveChartToFile() {
    const canvas = document.getElementById('functionChart');
    const link = document.createElement('a');
    link.download = 'ln_function_chart.png';
    link.href = canvas.toDataURL('image/png');  // Canvas → PNG
    link.click();
}
```

**Объяснение**:
- `canvas.toDataURL('image/png')` - конвертирует canvas в PNG
- Возвращает data URL (base64)
- Скачиваем через временную ссылку

### Использование

```html
<canvas id="functionChart"></canvas>
<button onclick="chartsDemo.restartAnimation()">Повторить анимацию</button>
<button onclick="chartsDemo.saveChartToFile()">Сохранить график</button>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="{% static 'js/charts-demo.js' %}"></script>
<script>
    const chartsDemo = new ChartsDemo();
</script>
```

---

## Задание 11: Анимация при скроллинге

**Файл**: `static/js/scroll-animations.js`, `static/css/scroll-animations.css`
**Страница**: `/realty/` (каталог недвижимости) + `/js-tasks/`
**Вариант 13**: Дома появляются при прокрутке страницы (в обоих направлениях)

### Описание
Использование **Intersection Observer API** для анимации элементов при попадании в область видимости. Анимации работают в обратном порядке - при скролле вверх элементы снова анимируются.

### Структура класса

```javascript
class ScrollAnimations {
    constructor(options) {
        this.options = {
            threshold: 0.15,      // 15% элемента видно
            rootMargin: '0px',
            animateOnce: false    // false = анимации повторяются
        };
        this.observer = null;
        this.animatedElements = new Set();
        this.init();
    }

    init() { /*...*/ }
    observeElements() { /*...*/ }
    handleIntersection(entries) { /*...*/ }
    animateElement(element) { /*...*/ }
    resetElement(element) { /*...*/ }
}
```

### Ключевой код

#### 1. Создание Intersection Observer

```javascript
init() {
    // Проверка поддержки браузером
    if (!('IntersectionObserver' in window)) {
        console.warn('Intersection Observer не поддерживается');
        this.showAllAnimations();  // Fallback - показать все сразу
        return;
    }

    // Создаем observer
    this.observer = new IntersectionObserver(
        (entries) => this.handleIntersection(entries),
        {
            threshold: this.options.threshold,     // Порог видимости (15%)
            rootMargin: this.options.rootMargin    // Отступ от viewport
        }
    );

    this.observeElements();
}
```

**Объяснение**:
- `IntersectionObserver` - современный API для отслеживания видимости
- `threshold: 0.15` - callback сработает когда 15% элемента появится
- `rootMargin` - увеличивает/уменьшает зону обнаружения
- Проверка `in window` - fallback для старых браузеров

#### 2. Регистрация элементов для наблюдения

```javascript
observeElements() {
    const elements = document.querySelectorAll('[data-scroll]');

    elements.forEach((element, index) => {
        // Каскадная задержка
        if (element.dataset.scrollCascade) {
            const delay = index * 0.1;  // 100ms между элементами
            element.style.animationDelay = `${delay}s`;
        }

        // Изначально скрываем
        element.style.opacity = '0';

        // Начинаем наблюдение
        this.observer.observe(element);
    });
}
```

**Объяснение**:
- `[data-scroll]` - атрибут-селектор, находит элементы с `data-scroll`
- `data-scroll-cascade` - атрибут для каскадной анимации
- `animationDelay` - задержка перед стартом анимации
- `observer.observe(element)` - начать отслеживать элемент

#### 3. Обработка пересечений

```javascript
handleIntersection(entries) {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            // Элемент ВОШЕЛ в viewport
            const element = entry.target;

            // Пропускаем если уже анимировали и animateOnce=true
            if (this.options.animateOnce && this.animatedElements.has(element)) {
                return;
            }

            this.animateElement(element);
            this.animatedElements.add(element);

            if (this.options.animateOnce) {
                this.observer.unobserve(element);  // Прекращаем наблюдение
            }
        } else if (!this.options.animateOnce) {
            // Элемент ВЫШЕЛ из viewport и animateOnce=false
            this.resetElement(entry.target);  // Убираем анимацию
        }
    });
}
```

**Объяснение**:
- `entry.isIntersecting` - `true` когда элемент виден
- `Set` - коллекция уникальных значений, для отслеживания анимированных элементов
- `unobserve()` - перестать следить за элементом
- При `animateOnce: false` анимации повторяются

#### 4. Запуск анимации

```javascript
animateElement(element) {
    const animationType = element.dataset.scroll || 'fade';

    element.style.opacity = '1';
    element.classList.add('scroll-animate');
    element.classList.add(`scroll-${animationType}`);

    // Событие завершения анимации
    element.addEventListener('animationend', () => {
        element.classList.add('scroll-animated');
    }, { once: true });  // Сработает только один раз
}
```

**Объяснение**:
- `element.dataset.scroll` - читает `data-scroll="fade"`
- `scroll-${animationType}` - добавляет класс `scroll-fade`, `scroll-slide-bottom` и т.д.
- `animationend` - событие когда CSS анимация завершилась
- `{ once: true }` - listener удалится после первого срабатывания

#### 5. Сброс анимации (для повторного использования)

```javascript
resetElement(element) {
    element.classList.remove('scroll-animate', 'scroll-animated');

    const animationType = element.dataset.scroll || 'fade';
    element.classList.remove(`scroll-${animationType}`);

    element.style.opacity = '0';
}
```

### CSS анимации

```css
/* Базовая настройка */
.scroll-animate {
    animation-duration: 1s;
    animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94);
    animation-fill-mode: both;
}

/* Появление снизу */
@keyframes slideInBottom {
    from {
        opacity: 0;
        transform: translateY(100px);  /* Сдвиг вниз на 100px */
    }
    to {
        opacity: 1;
        transform: translateY(0);      /* Исходная позиция */
    }
}

.scroll-slide-bottom {
    animation-name: slideInBottom;
}

/* Отключение для пользователей с prefers-reduced-motion */
@media (prefers-reduced-motion: reduce) {
    [data-scroll],
    .scroll-animate {
        animation: none !important;
        opacity: 1 !important;
    }
}
```

**Объяснение**:
- `@keyframes` - определяет анимацию
- `transform: translateY(100px)` - сдвиг по оси Y
- `animation-fill-mode: both` - применяет стили из 0% и 100%
- `prefers-reduced-motion` - уважение к настройкам accessibility

### Применение к карточкам каталога

```javascript
// В catalog-pagination.js
createCard(item) {
    const card = document.createElement('div');
    card.className = 'property-card';

    // ЛР3 Задание 11: анимация при скролле
    card.dataset.scroll = 'slide-bottom';

    card.innerHTML = `...`;
    return card;
}

// После рендера регистрируем в observer
if (typeof scrollAnimations !== 'undefined') {
    const newCards = document.querySelectorAll('.property-card[data-scroll]');
    newCards.forEach(card => {
        scrollAnimations.observe(card);
    });
}
```

### Использование

```html
<!-- Подключение -->
<link rel="stylesheet" href="{% static 'css/scroll-animations.css' %}">
<script src="{% static 'js/scroll-animations.js' %}"></script>

<!-- Использование в HTML -->
<div data-scroll="fade">Плавное появление</div>
<div data-scroll="slide-bottom">Появление снизу</div>
<div data-scroll="scale">Увеличение</div>

<!-- Каскадная анимация -->
<div data-scroll="scale" data-scroll-cascade>Карточка 1</div>
<div data-scroll="scale" data-scroll-cascade>Карточка 2</div>
<div data-scroll="scale" data-scroll-cascade>Карточка 3</div>
```

```javascript
// Инициализация
const scrollAnimations = new ScrollAnimations({
    threshold: 0.15,
    animateOnce: false  // Анимации повторяются
});

// Добавление новых элементов
scrollAnimations.observe(element);

// Перезапуск всех анимаций
scrollAnimations.restartAll();
```

---

## Краткая справка по остальным заданиям

### Задание 3: Таблица сотрудников
- Файл: `static/js/employees-table.js`
- Загрузка данных через `fetch()` API
- Сортировка по столбцам
- Фильтрация по тексту
- Пагинация (постраничная навигация)
- Валидация телефона (regex) и URL

### Задание 4: Генератор форм (URL input)
- Файл: `static/js/form-generator.js`
- Создание `<input type="url">` динамически
- Установка атрибутов: `placeholder`, `required`, `pattern`
- Валидация URL через HTML5 и regex

### Задание 5: Пагинация каталога
- Файл: `static/js/catalog-pagination.js`
- Загрузка данных через API
- Постраничное отображение (6/12/24 элемента)
- Умная пагинация (1 ... 5 6 7 ... 20)

### Задание 6: 3D эффект для карточек
- Файл: `static/js/card-3d-effect.js`
- Отслеживание позиции мыши
- `transform: perspective()` и `rotateX/Y`
- Эффект блика через градиент

### Задание 7: Проверка возраста
- Файл: `static/js/age-validator.js`
- Модальное окно
- Валидация даты рождения
- Расчет возраста

### Задание 9: Browser API
- Файл: `static/js/browser-api-demo.js`
- Geolocation API
- Battery Status API
- Speech Synthesis API
- Clipboard API

---

## Полезные ссылки

- **MDN Web Docs**: https://developer.mozilla.org/
- **Chart.js**: https://www.chartjs.org/
- **ES6 Classes**: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
- **Intersection Observer**: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
- **LocalStorage**: https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage

---

## Часто используемые методы

### DOM манипуляции
```javascript
document.querySelector('.class')       // Найти первый элемент
document.querySelectorAll('.class')    // Найти все элементы
element.classList.add('class')         // Добавить класс
element.classList.remove('class')      // Убрать класс
element.classList.toggle('class')      // Переключить класс
element.addEventListener('click', fn)  // Добавить обработчик
```

### Массивы
```javascript
arr.forEach(item => {})     // Перебор
arr.map(item => {})         // Преобразование
arr.filter(item => {})      // Фильтрация
arr.find(item => {})        // Поиск первого
arr.includes(value)         // Проверка наличия
arr.push(item)              // Добавить в конец
```

### Async/Await
```javascript
async function loadData() {
    const response = await fetch('/api/data');
    const data = await response.json();
    return data;
}
```

### LocalStorage
```javascript
localStorage.setItem('key', 'value')   // Сохранить
localStorage.getItem('key')            // Получить
localStorage.removeItem('key')         // Удалить
localStorage.clear()                   // Очистить все
```

---

**Конец шпаргалки**
